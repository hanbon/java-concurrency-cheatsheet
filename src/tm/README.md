## 线程管理 (thread management)

### 目录导航

- [线程的创建、运行与信息的获取](#线程的创建、运行与信息的获取)

- [线程的中断与处理](#线程的中断与处理)

- [等待线程结束和谦让](#等待线程结束和谦让)

- [守护进程的创建与运行](#守护进程的创建与运行)

- [线程中未受检异常的处理](#线程中未受检异常的处理)

- [线程中局部变量的使用](#线程中局部变量的使用)

- [线程的分组和未受检异常的处理](#线程的分组和未受检异常的处理)


### [线程的创建、运行与信息的获取](tm_01/Main.java "查看示例")

每个 Java 程序至少有一个执行线程。当运行程序的时候，JVM 会启动这个执行线程来调用程序的 main() 方法。

当调用 Thread 对象的 `start()` 方法时，另一个执行线程将被创建。

当所有的非守护线程都运行完成的时候，Java 程序结束。

如果初始线程结束了，其余的线程仍将继续执行直到结束。

如果一个线程调用了 `System.exit()`，所有线程都将结束。


#### 创建线程的两种方式：

- 继承 Thread 类，并重写该类的 `run()` 方法。

- 创建一个实现 Runnable 接口的类。使用带参数的 Thread 构造器来创建 Thread 对象。参数是实现 Runnable 接口的类的一个对象。

- 注：还可以使用 Callable + FutureTask 的方式创建：使用 FutureTask 类来包装 Callable 对象，使用 FutureTask 对象作为 Thread 对象参数
  创建并启动线程，最后调用 FutureTask 对象的 `get()` 方法来获得线程执行结束后的返回值。本质上是 FutureTask 实现了 Runnable 接口。


#### 线程的信息：

- ID：线程唯一标识符。

- Name: 线程名称。

- Priority: 线程优先级，从低到高为 1 到 10。注意：线程优先级是 Java 平台上最不可移植的特征。当设计多线程应用程序的时候，一定不要依赖于线程的优先级。
  因为线程调度优先级操作是没有保障的，只能把线程优先级作用作为一种提高程序效率的方法，但是要保证程序不依赖这种操作。

- Status: 线程的状态，有 6 种。

    - **NEW**: 线程被创建，还没有运行 `start()` 方法。

    - **RUNNABLE**: 调用 `start()` 后线程在执行 `run()` 方法且没有阻塞时状态为 RUNNABLE。 
      不过，RUNNABLE 不代表 CPU 一定在执行该线程的代码，可能正在执行也可能在等待操作系统分配时间片，只是它没有在等待其他条件，比如 IO

    - **BLOCKED**: 阻塞状态，等待锁的释放，比如线程A进入了一个 synchronized 方法，线程B也想进入这个方法， 
      但是这个方法的锁已经被线程A获取了，这个时候线程B就处于 BLOCKED 状态。

    - **WAITING**: 等待状态，处于等待状态的线程是由于执行了3个方法中的任意方法。

        - Object 的 `wait()` 方法，并且没有使用 timeout 参数

        - Thread 的 `join()` 方法，没有使用 timeout 参数 

        - LockSupport 的 `park()` 方法

        处于 waiting 状态的线程会等待另外一个线程处理特殊的行为。 
        再举个例子，如果一个线程调用了一个对象的 `wait()` 方法，那么这个线程就会处于 WAITING 状态直到另外一个线程调用这个对象的 `notify()` 或者 `notifyAll()` 方法后才会解除这个状态。

    - **TIME_WAITING**: 有等待时间的等待状态，比如调用了以下几个方法中的任意方法，并且指定了等待时间，线程就会处于这个状态。 

        - Thread 的 `sleep()` 方法

        - Object 的 `wait()` 方法，带有时间

        - Thread 的 `join()` 方法，带有时间

        - LockSupport 的 `parkNanos()` 方法，带有时间

        - LockSupport 的 `parkUntil()` 方法，带有时间

    - **TERMINATED**: 线程运行结束后状态为 TERMINATED


### [线程的中断与处理](tm_02/Main.java "查看示例")

Java 提供了中断机制，可以使用来结束一个线程。

这种机制要求线程检查它是否被中断了，然后决定是不是响应这个中断请求。

线程允许忽略中断请求并继续执行。

Thread 类有一个表明线程是否被中断的布尔型中断标记。

`interrupt()` 不会中断正在执行的线程，只是将线程的标志位设置成 true。

但是如果线程在调用`sleep()`，`join()`，`wait()`方法时线程被中断，则这些方法会抛出 InterruptedException ，在 catch 块中捕获到这个异常时，
线程的中断标志位已经被设置成 false 了，因此在此 catch 块中调用 `isInterrupted()`，`Thread.interrupted()` 始终都为 false。

`interrupted()` 和 `isInterrupted()` 都返回中断标记的值。

`interrupted()` 是静态方法，作用于当前线程，会清除线程的中断标记(true -> false)。换句话说，如果连续两次调用该方法，则第二次调用将返回 false
（在第一次调用已清除了其中断状态之后，且第二次调用检验完中断状态前，当前线程再次中断的情况除外）。 

`isInterrupted()` 是作用于调用该方法的线程对象所对应的线程，不会对中断标记有影响。（线程对象对应的线程不一定是当前运行的线程。
例如我们可以在 A 线程中去调用 B 线程对象的 `isInterrupted()` 方法）

如果不能抛出 InterruptedException（例如：`Thread.sleep()` 语句放在了 `run()` 方法中，这个方法不允许抛出任何受检查的异常），
但又想告诉上层调用者这里发生了中断的时候，就只能在catch里面调用 `interrupt()` 来重置中断状态了。


### [等待线程结束和谦让](tm_03/Main.java "查看示例")

在多线程应用中，很多时候，一个线程的输入可能非常依赖另外一个或多个线程的输出，为了达到这个目的可以使用 `join()` 方法。

当一个线程对象的 `join()` 方法被调用时，调用它的线程将会被挂起，直到这个线程完成。

使用 `join(long millis)` 或 `join(long millis, long nanos)` 来设置最大等待时间。

 `join()` 方法的本质是让调用线程 `wait()` 在当线程对象实例上。
 当线程执行完成后，被等待的线程会在退出前调用 `notifyAll()` 通知所有的等待线程继续执行。
 
 因此，值得注意的是：不要在应用程序中 Thread 对象的实例上使用类似 `wait()` 或 `notify()` 等方法，因为这很可能会影响系统 API 的工作，或被系统 API 所影响。
 
 `Thread.yeild()` 是一个静态原生方法，作业是暂停当前正在执行的线程对象，并执行其他线程。注意点如下：

- 仅告诉当前正在执行的线程把运行机会交给线程池中拥有相同优先级的线程。

- 不能保证使得当前正在运行的线程迅速转换到可运行的状态。

- 仅能使一个线程从运行状态转到可运行状态，而不是等待或阻塞状态。

- 一般这个方法多做调试使用。


### [守护进程的创建与运行](tm_04/Main.java "查看示例")

Java 里有种特殊的线程叫守护（Daemon）线程。

这种线程的优先级很低，当同一个应用程序没有其他的线程运行的时候，守护线程才运行。

当守护线程是程序中唯一运行的线程时，守护线程执行结束，JVM 也就结束了这个程序。

因为这种特性，守护线程通常被用来作为同一个应用程序中的普通线程（用户线程）服务提供者。

它们通常是无限循环的，等待服务请求或执行线程的任务。

它们不能做重要的工作，因为我们不知道守护线程什么时候能够获取 CPU 时钟。

一个典型的守护进程是 Java 的垃圾回收器。

注意：

- `setDaemon(true)` 必须在 `start()`之前设置，否则会跑出一个 IllegalThreadStateException 异常。你不能把正在运行的常规线程设置为守护线程。

- 在Daemon线程中产生的新线程也是Daemon的。

- 在 finally 块中的代码也可能不会执行。所以，守护线程应该永远不去访问固有资源，如文件、数据库，因为它会在任何时候甚至在一个操作的中间发生中断。总之，对于可能执行任何类型的 I/O 操作的任务使用守护线程是危险的。

### [线程中未受检异常的处理](tm_05/Main.java "查看示例")

Java 中的异常

- 受检异常（Checked Exception）除了 RuntimeException 及其子类以外，其他的 Exception 类及其子类都属于这种异常，当程序中可能出现这类异常，要么使用 try-catch 语句进行捕获，要么用 throws 语句抛出，否则编译无法通过。

- 未受检异常（Unchecked Exception）包括 RuntimeException 及其子类和 Error，编译器不要求强制处理。

因为线程的 run() 方法不支持 throws 语句，所以当线程对象的 run() 方法抛出受检异常时，必须捕获并且处理它们。
当未受检异常从 run() 方法抛出时，默认是在控制台输出堆栈记录并且退出程序。

Java 在 1.5 后提供了一种在线程对象里捕获和处理未受检异常的一种机制，使用线程对象的 `setUncaughtExceptionHandler()` 方法，设置处理未受检异常的
Handler, 参数为 `Thread.UncaughtExceptionHandler` 对象的实例。

Thread 类还有另一个静态方法 `setDefaultUncaughtExceptionHandler` 可以处理未受检异常，这个方法为所有的线程创建一个默认的异常处理器。

当线程抛出一个未受检异常，JVM 将为异常寻找以下三种可能的异常处理器：

1. 查找线程对象的未受检异常处理器。

2. 如果找不到，JVM 继续查找线程对象所在的线程组的未受检异常处理器。

3. 如果还是找不到，JVM 将继续查找默认的未受检异常处理器。

如果没有一个处理器存在，JVM 将堆栈异常记录打印到控制台，并退出程序。


### [线程中局部变量的使用](tm_06/Main.java "查看示例")

共享数据是并发程序中最核心的问题之一，对于继承了 Thread 类或实现了 Runnable 接口的对象来说尤为重要。

如果创建的对象是实现了 Runnable 接口的类的实例，用它作为参数创建多个线程对象并启动这些线程，那么所有的线程将共享相同的属性。

在某种情况下，这个对象的属性不能被所有的线程共享，可以使用线程局部变量（Thread-Local Variable）来达到这个效果。

ThreadLocal 提供了四个方法：

- `protected T initialValue()` 返回此线程局部变量的初始值

- `public T get()` 此线程局部变量的当前线程的值

- `public void set(T value)` 存储在此线程局部变量的当前线程副本中的值

- `public void remove()` 移除此线程局部变量的值

在适当的场景下使用 ThreadLocal 可以提高性能，主要取决于共享对象的内部逻辑。

注意内存泄露的问题：

- ThreadLocal 中的变量是维护在 Thread 类内部的，这意味着只要线程不退出，对象的引用将一直存在。

- 如果希望及时回收对象，最好使用 `remove()` 方法将变量移除，防止可能出现的内存泄漏。

- Java 为了最小化减少内存泄露的可能性和影响，在调用 ThreadLocal 的 `get()`和 `set()` 的时候都会清除线程 ThreadLocalMap 里所有 key 为 null 的 value。

- 但是在使用线程池（如固定大小的线程池）的情况下，如果没有及时清理 ThreadLocal，线程没有被销毁，而仅仅是放回线程池，不仅可能出现内存泄漏的问题，更严重的是可能导致业务逻辑出现问题（[示例](tm_06/ThreadLocalMemoryLeak.java)）。

Java 并发 API 包含了 InheritableThreadLocal 类，允许一个线程创建的所有子线程访问其父线程的值：当一个子线程被创建时，子接受父值的所有可继承线程局部变量的初始值。
可以选择覆盖 `childValue()` 方法，这个方法用来初始化子线程中线程局部变量的值，它使用父线程在线程局部变量中的值作为传入参数。

### [线程的分组和未受检异常的处理](tm_07/Main.java "查看示例")

Java 提供 ThreadGroup 类表示一组线程。线程组可以包含线程对象和其他线程组对象，是一个树形结构。

这允许我们把一个组的线程当作一个单一的单元，对组内线程对象进行访问并操作它们。例如，对于一些执行同样任务的线程，你想控制它们，不管多少线程在运行，
只需要一个单一的调用，所有的这些线程的运行都会被中断。

一些方法：

- `list()` 打印线程组对象的信息。

- `activeCount()` 返回当前线程的线程组中活动线程的个数。

- `enumerate()` 复制当前线程的线程组和子线程组中的活动线程到指定数组。

- `interrupt()` 中断线程组中所有的线程，包括子线程组。


