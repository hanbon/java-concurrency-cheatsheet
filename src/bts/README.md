## 线程同步基础 (basic thread synchronization)

多个执行线程共享一个资源的情景，是最常见的并发编程情景之一。

在并发应用中常常遇到这样的场景：多个线程读/写相同的数据，或者访问相同的文件或数据库连接。
为了防止这些共享资源有可能出现的错误或数据不一致，我们必须实现一些机制来防止这些错误的发生。

为了解决这些问题，人们引入了临界区（Critical Section）概念。

临界区是一个用以访问共享资源的代码块，这个代码块在同一时间内只允许一个线程执行。

为了帮助编程人员实现这个临界区，Java（以及大多数编程语言）提供了同步机制。
当一个线程试图访问一个临界区时，它将使用一种同步机制来查看是不是已经有其他线程进入临界区。
如果没有其他线程进入临界区，它就可以进入临界区；如果已经有线程进入了临界区，他就被同步机制挂起，直到进入的线程离开这个临界区。
如果在等待进入临界区的线程不止一个，JVM 会选择其中一个，其余的将继续等待。

下面将讲解如何使用 Java 语言提供的两种基本同步机制：

- synchronized 关键字机制

- Lock 接口及其实现机制


### 目录导航

- [使用 synchronized 实现同步](#使用synchronized实现同步)

- [在同步代码中使用条件](#在同步代码中使用条件)


### [使用synchronized实现同步](bts_01/Parking.java "查看示例")

分类：

- 使用 synchronized 同步实例方法

- 使用 synchronized 同步静态方法

- 使用 synchronized 同步代码块

    - 同步单一对象锁，使用 `this` 指代正在执行方法所属的对象
    
    - 同步类锁，使用 `*.class`
    
    - 使用非属性依赖，即使用其他对象

每一个用 synchronized 关键字声明的方法都是临界区。在同一时间内只允许一个执行线程访问。

注意：如果一个线程访问同步实例方法，另一个线程访问同步静态方法，而这两个方法都改变了相同的数据，可能会出现数据不一致的错误。（[示例](bts_01/SyncMethods.java)）

synchronized 是可重入的。即当一个线程在访问一个对象的同步方法块时，它还可以调用这个对象的其他同步方法，也包含正在执行的方法，而不必再次获取这个方法的访问权。

通过使用 synchronized 保护代码块（而不是整个方法），以获得更好的性能。


### [在同步代码中使用条件](bts_02/Main.java "查看示例")

在并发编程中一个典型的问题是生产者-消费者（Producer-Consumer）问题。
有一个数据缓冲区，一个或多个数据生产者将把数据放入这个缓冲区，一个或多个消费者将数据从缓冲区取走。

这个缓冲区是一个共享数据结构，必须使用同步机制控制对它的访问。例如使用 synchronized 关键字，但是会受到更多的限制。
如果缓冲区满，则生产者就不能再放入数据；如果缓冲区空，消费者就不能读取数据。

对于这些场景，Java 在 Object 类中提供了 `wait()`、`notify()`、`notifyAll()` 方法。
线程可以在同步代码块中调用 `wait()` 方法。如果在同步代码块之外调用 `wait()` 方法， JVM 会抛出 IllegalMonitorStateException 异常。
当一个线程调用 `wait()` 方法，JVM 将这个线程休眠，并且释放控制这个同步代码块的对象，同时允许其他线程执行这个对象控制的其他同步代码块。
为了唤醒这个线程，必须在这对象控制的某个同步代码块中调用 `notify()` 或 `notifyAll()` 方法。

使用应该保持用 wait 循环模式来调用 wait 方法，永远不要在循环之外调用 `wait()` 方法。

```
synchronized(obj) {
    while(<condition does not hold>) {
        obj.wait()
    }
}
```

循环可以在等待之前和之后测试条件。

 - 在等待之前测试条件，当条件已经成立时就跳过等待，这对于确保活性（liveness）是必要的。
 如果条件已经成立，并且在线程等待之前，`notify()` 或 `notifyAll()` 方法已经被调用，则无法保证该线程将会从等待中苏醒过来。
 
 - 在等待之后测试条件，如果条件不成立的话继续等待，这对于确保安全性（safety）是必要的。
 当条件不成立的时候，如果线程继续执行，则可能会破坏被锁保护的约束关系。
 
一个相关的话题是，为了唤醒正在等待的线程，应该使用 `notify()` 还是 `notifyAll()`。
一个常见的说法是，总是应该使用 `notifyAll()` 。这是合理而保守的建议。它总会产生正确的结果，因为它可以保证唤醒所有需要被唤醒的线程。
可能会唤醒其他一些线程，但是不会影响程序的正确性。这些线程醒来后，会检查它们正在等待的条件，如果发现条件并不满足，就会继续等待。

最后一点，并发工具优于 wait 和 notify。





















